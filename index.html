<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <title>Venkata Ramana Reddy, Pulugari</title>
</head>

<body class="bg-gradient-to-b from-gray-800 to-black h-screen flex items-center justify-center">

    <canvas id="canvas" class="absolute top-0 left-0"></canvas>

    <div
        class="bg-opacity-10 bg-white p-8 rounded-lg md:w-8/12 w-99vw md:h-auto h-full overflow-auto text-white text-center z-10">

        <h1 class="text-2xl font-bold mb-2">Venkata Ramana Reddy, Pulugari</h1>
        <p class="text-lg text-gray-300 mb-4">Full Stack Developer</p>

        <div class="text-left text-gray-200">
            <ul class="list-outside hover:list-inside">
                <li class="mb-2">üöÄ Self-taught coding wizard from India üáÆüá≥, now sprinkling magic in the USA üá∫üá∏
                </li>
                <li class="mb-2">üéì Currently MS(Computer Science) at Binghamton University, NY (Class of 2024)</li>
                <li class="mb-2">üíº Former R&D sorcerer at Nestor Analytics and code conjurer at Infobelt Inc</li>
                <li class="mb-2">üõ†Ô∏è Crafted Anki Addons, DevInitiate, Groove Graphics, and more. Not just code, it's
                    pure sorcery! ‚ú®
                </li>
                <li class="mb-2">üíñ Fluent in JavaScript, React, Canvas ‚Äì weaving spells on the web. Python and Shell
                    Script are my
                    enchanted scrolls for automation.</li>
                <li class="mb-2">üîÆ Currently learning and mastering the magical realms of Rust and AWS! ü¶Ä‚òÅÔ∏è</li>
            </ul>

        </div>

        <div class="mt-9 flex justify-between">
            <a type="button" target="_blank" href="https://github.com/itsmepvr/" data-te-ripple-init
                data-te-ripple-color="light"
                class="mb-2 flex rounded px-5 py-2 text-xs md:px-6 md:py-2.5 md:text-sm font-medium uppercase leading-normal text-white shadow-md transition duration-150 ease-in-out hover:shadow-lg focus:shadow-lg focus:outline-none focus:ring-0 active:shadow-lg"
                style="background-color: #333;">

                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 h-3 w-3 md:h-3.5 md:w-3.5" fill="currentColor"
                    viewBox="0 0 24 24">
                    <path
                        d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z" />
                </svg>

                Github
            </a>


            <a type="button" target="_blank" href="https://linkedin.com/in/itsmepvr/" data-te-ripple-init
                data-te-ripple-color="light"
                class="mb-2 flex rounded px-5 py-2 text-xs md:px-6 md:py-2.5 md:text-sm font-medium uppercase leading-normal text-white shadow-md transition duration-150 ease-in-out hover:shadow-lg focus:shadow-lg focus:outline-none focus:ring-0 active:shadow-lg"
                style="background-color: #0077b5;">

                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 h-3 w-3 md:h-3.5 md:w-3.5" fill="currentColor"
                    viewBox="0 0 24 24">
                    <path
                        d="M4.98 3.5c0 1.381-1.11 2.5-2.48 2.5s-2.48-1.119-2.48-2.5c0-1.38 1.11-2.5 2.48-2.5s2.48 1.12 2.48 2.5zm.02 4.5h-5v16h5v-16zm7.982 0h-4.968v16h4.969v-8.399c0-4.67 6.029-5.052 6.029 0v8.399h4.988v-10.131c0-7.88-8.922-7.593-11.018-3.714v-2.155z" />
                </svg>

                LinkedIn
            </a>


            <!-- Resume button -->
            <a type="button" target="_blank"
                href="https://docs.google.com/document/d/1UavcaHLdkElaRqMIKqSMasWkm8008Q1G/edit?usp=drive_link&ouid=117741105136415347903&rtpof=true&sd=true"
                data-te-ripple-init data-te-ripple-color="light"
                class="mb-2 flex rounded px-5 py-2 text-xs md:px-6 md:py-2.5 md:text-sm font-medium uppercase leading-normal text-white shadow-md transition duration-150 ease-in-out hover:shadow-lg focus:shadow-lg focus:outline-none focus:ring-0 active:shadow-lg"
                style="background-color: #4CAF50;">

                <svg xmlns="http://www.w3.org/2000/svg" class="mr-2 h-3 w-3 md:h-3.5 md:w-3.5" fill="currentColor"
                    viewBox="0 0 24 24">
                    <path
                        d="M19.54 0c1.356 0 2.46 1.104 2.46 2.472v21.528l-2.58-2.28-1.452-1.344-1.536-1.428.636 2.22h-13.608c-1.356 0-2.46-1.104-2.46-2.472v-16.224c0-1.368 1.104-2.472 2.46-2.472h16.08zm-4.632 15.672c2.652-.084 3.672-1.824 3.672-1.824 0-3.864-1.728-6.996-1.728-6.996-1.728-1.296-3.372-1.26-3.372-1.26l-.168.192c2.04.624 2.988 1.524 2.988 1.524-1.248-.684-2.472-1.02-3.612-1.152-.864-.096-1.692-.072-2.424.024l-.204.024c-.42.036-1.44.192-2.724.756-.444.204-.708.348-.708.348s.996-.948 3.156-1.572l-.12-.144s-1.644-.036-3.372 1.26c0 0-1.728 3.132-1.728 6.996 0 0 1.008 1.74 3.66 1.824 0 0 .444-.54.804-.996-1.524-.456-2.1-1.416-2.1-1.416l.336.204.048.036.047.027.014.006.047.027c.3.168.6.3.876.408.492.192 1.08.384 1.764.516.9.168 1.956.228 3.108.012.564-.096 1.14-.264 1.74-.516.42-.156.888-.384 1.38-.708 0 0-.6.984-2.172 1.428.36.456.792.972.792.972zm-5.58-5.604c-.684 0-1.224.6-1.224 1.332 0 .732.552 1.332 1.224 1.332.684 0 1.224-.6 1.224-1.332.012-.732-.54-1.332-1.224-1.332zm4.38 0c-.684 0-1.224.6-1.224 1.332 0 .732.552 1.332 1.224 1.332.684 0 1.224-.6 1.224-1.332 0-.732-.54-1.332-1.224-1.332z" />
                </svg>

                Resume
            </a>
        </div>
    </div>

    <script>

        // canvas context
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        // setting full width and height to canvas
        const w = window.innerWidth * 0.01 * 100;
        const h = (window.innerHeight * 0.01 * 100) - 2;
        canvas.width = w;
        canvas.height = h;
        // constants
        const gridSize = 20;
        const snake = [{ x: 10, y: 10 }];
        let xVelocity = 1;
        let yVelocity = 0;
        let tailLength = 30;

        var blocks_used = [];

        const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, '#11244C'); // Dark gray
        gradient.addColorStop(0.5, '#0D1B39');   // Slightly lighter gray
        gradient.addColorStop(1, '#000');     // Black

        function clearScreen() {
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // Function to convert hex color to RGBA format
        function hexToRGBA(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);

            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        class Snake {
            constructor(ctx, gridSize, tileLength, headColor = 'red', tailColor = 'white') {
                this.ctx = ctx;
                this.gridSize = gridSize;
                this.tailLength = tileLength;
                this.xGrid = (w / gridSize) / 2;
                this.yGrid = (h / gridSize) / 2;
                this.xVelocity = 1;
                this.yVelocity = 0;
                this.headX = getRandomNumber(1, this.xGrid);
                this.headY = getRandomNumber(1, this.xGrid);
                this.snake = [{ x: this.headX, y: this.headY }];
                this.directions = [];
                this.current_direction = 'right';
                this.headColor = headColor;
                this.tailColor = tailColor;
                this.opacity = 0.1;
            }

            reload() {
                this.xVelocity = 1;
                this.yVelocity = 0;
                this.headX = getRandomNumber(1, this.xGrid);
                this.headY = getRandomNumber(1, this.xGrid);
                this.snake = [{ x: this.headX, y: this.headY }];
                this.directions = [];
                this.cache_directions = [];
                this.move();
            }

            drawSnake() {
                this.ctx.fillStyle = hexToRGBA(this.headColor, this.opacity);
                this.ctx.fillRect(this.snake[0].x * this.gridSize, this.snake[0].y * this.gridSize, this.gridSize - 2, this.gridSize - 2);

                for (let i = 1; i < this.snake.length; i++) {
                    let part = this.snake[i];
                    this.ctx.fillStyle = hexToRGBA(this.tailColor, this.opacity);
                    this.ctx.fillRect(part.x * this.gridSize, part.y * this.gridSize, this.gridSize - 2, this.gridSize - 2);
                }
            }

            updateSnake() {
                this.snake.unshift({ x: this.headX, y: this.headY });
                if (this.snake.length > this.tailLength + 1) {
                    this.snake.pop();
                }
            }

            randomDirection() {

                this.directions = ["up", "left", "right", "down"];
                if (this.yVelocity == 1) this.update_directions('up');
                if (this.yVelocity == -1) this.update_directions('down');
                if (this.xVelocity == 1) this.update_directions('left');
                if (this.xVelocity == -1) this.update_directions('right');

                if (this.headX <= 0) this.update_directions('left');
                if (this.headX >= (w / this.gridSize) - 1) this.update_directions('right');
                if (this.headY <= 0) this.update_directions('up');
                if (this.headY >= (h / this.gridSize) - 2) this.update_directions('down');

                this.collision();

                this.headX += this.xVelocity;
                this.headY += this.yVelocity;

            }

            check_self_collision(x, y) {
                let collision = false;
                let head_x = this.headX + x;
                let head_y = this.headY + y;
                for (let i = 0; i < this.snake.length; i++) {
                    let part = this.snake[i];
                    if (part.x === head_x && part.y === head_y) {
                        collision = true;
                        break;
                    }
                }
                return collision;
            }

            collision() {
                if (this.directions.length == 0) {
                    this.reload();
                }

                let direction = this.getRandomElementWithProbabilities();

                let x = 0, y = 0;
                if (direction == 'left') {
                    x -= 1;
                    y = 0;
                } else if (direction == 'right') {
                    x += 1;
                    y = 0;
                }
                if (direction == 'up') {
                    y -= 1;
                    x = 0;
                } else if (direction == 'down') {
                    y += 1;
                    x = 0;
                }

                if (this.check_self_collision(x, y)) {
                    this.update_directions(direction);
                    this.collision();
                } else {
                    this.current_direction = direction;
                    this.xVelocity = x;
                    this.yVelocity = y;
                }
            }

            getRandomElementWithProbabilities() {
                var probabilities = {}
                for (let i = 0; i < this.directions.length; i++) {
                    if (this.directions[i] == this.current_direction) {
                        probabilities[this.directions[i]] = 0.6;
                    } else {
                        probabilities[this.directions[i]] = 0.2;
                    }
                }

                const rand = Math.random();

                let cumulativeProbability = 0;

                for (const [element, probability] of Object.entries(probabilities)) {
                    cumulativeProbability += probability;

                    if (rand < cumulativeProbability) {
                        return element;
                    }
                }
                return this.directions[Math.floor(Math.random() * this.directions.length)];
            }


            move() {
                this.randomDirection();
                this.updateSnake();
                this.drawSnake();
            }

            update_directions(dir) {
                let indexToRemove = this.directions.indexOf(dir);

                if (indexToRemove !== -1) {
                    this.directions.splice(indexToRemove, 1);
                }
            }
        }

        function getRandomNumber(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }

        const distinctColorPairs = [
            ['#607D8B', '#ECEFF1'], // Blue Gray
            ['#FFC107', '#FFECB3'], // Amber
            ['#4CAF50', '#E8F5E9'], // Green
            ['#673AB7', '#EDE7F6'], // Deep Purple
            ['#FF5722', '#FFEB3B']  // Deep Orange
        ];

        let snake_1 = new Snake(ctx, gridSize, tailLength, 'red', 'white');
        let snake_2 = new Snake(ctx, gridSize, tailLength, 'blue', 'orange');

        let snakes = [];
        const SNAKES_COUNT = 4;
        for (let i = 0; i < SNAKES_COUNT; i++) {
            let color = '';
            if (i >= 5) color = distinctColorPairs[i - 5];
            else color = distinctColorPairs[i];
            snakes[i] = new Snake(ctx, gridSize, tailLength, color[0], color[1])
        }

        function gameLoop() {
            clearScreen();
            for (let i = 0; i < SNAKES_COUNT; i++) {
                snakes[i].move();
            }
        }

        clearScreen();

        setTimeout(() => {
            setInterval(gameLoop, 75);
        }, 1000);


    </script>
</body>

</html